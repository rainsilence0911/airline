<!DOCTYPE html>
<html>
<head>
<title>Air line chart</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript" src="js/matrix4x4.js"></script>
<script type="text/javascript" src="js/vector.js"></script>
<script type="text/javascript" src="js/shader1.1/texture.js"></script>
<script type="text/javascript" src="js/shader1.1/shader.js"></script>

<style type="text/css">
.displayItem {
    margin-top: 2px;
    border-style: solid;
    border-width: 1px;
    padding-left: 2px;
    cursor: pointer;
}

.closeButton {
    text-align: center;
    width: 20px;
    cursor: pointer;
    float: right;
}

</style>

<script id="line-fs" type="x-shader/x-fragment">
  precision mediump float;

  uniform bool uSelect;

  void main(void) {

    if (uSelect) {
      gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
    } else {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
  }

</script>

<script id="line-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }

</script>

<script id="shader-fs" type="x-shader/x-fragment">

    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;

        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = (uNMatrix * vec4(aVertexNormal, 1.0)).xyz;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>


<script type="text/javascript">

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;

    var moonRotationMatrix = new Matrix();

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }


    function handleMouseUp(event) {
        mouseDown = false;
    }


    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;

        var deltaX = newX - lastMouseX
        var newRotationMatrix = new Matrix();
        newRotationMatrix.rotate(deltaX / 10, 0, 1, 0);

        var deltaY = newY - lastMouseY;
        newRotationMatrix.rotate(deltaY / 10, 1, 0, 0);

        moonRotationMatrix = Matrix.multiply(newRotationMatrix, moonRotationMatrix);

        lastMouseX = newX
        lastMouseY = newY;
    }
    
	/**
	 * 2-dimension bezier curve
	 */
    function bezierCurve2(p0, p1, p2) {
      
      // point result
      var p = [];
      
      for (var t = 0; t <= 1.01; t+=0.01) {
        p.push(Math.pow((1 - t), 2) * p0[0] + 2 * t * (1 - t) * p1[0] + Math.pow(t, 2) * p2[0]);
        p.push(Math.pow((1 - t), 2) * p0[1] + 2 * t * (1 - t) * p1[1] + Math.pow(t, 2) * p2[1]);
        p.push(Math.pow((1 - t), 2) * p0[2] + 2 * t * (1 - t) * p1[2] + Math.pow(t, 2) * p2[2]);
      }
      return p;
    }

  function bezierCurve4(p0, p1, p2, p3, p4) {

    // point result
    var p = [];

    for (var t = 0; t <= 1.01; t += 0.01) {
      p.push(Math.pow((1 - t), 4) * p0[0] + 4 * t * Math.pow((1 - t), 3)
          * p1[0] + 6 * t * t * Math.pow((1 - t), 2) * p2[0] + 4
          * Math.pow(t, 3) * (1 - t) * p3[0] + Math.pow(t, 4) * p4[0]);
      p.push(Math.pow((1 - t), 4) * p0[1] + 4 * t * Math.pow((1 - t), 3)
          * p1[1] + 6 * t * t * Math.pow((1 - t), 2) * p2[1] + 4
          * Math.pow(t, 3) * (1 - t) * p3[1] + Math.pow(t, 4) * p4[1]);
      p.push(Math.pow((1 - t), 4) * p0[2] + 4 * t * Math.pow((1 - t), 3)
          * p1[2] + 6 * t * t * Math.pow((1 - t), 2) * p2[2] + 4
          * Math.pow(t, 3) * (1 - t) * p3[2] + Math.pow(t, 4) * p4[2]);
    }
    return p;
  }

  var allPoints = {};
  var radius = 2;
  function initBuffers() {
    var latitudeBands = 180;
    var longitudeBands = 360;

    var vertexPositionData = [];
    var normalData = [];
    var textureCoordData = [];
    for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
        var phi = longNumber * 2 * Math.PI / longitudeBands;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = cosPhi * sinTheta;
        var y = cosTheta;
        var z = sinPhi * sinTheta;
        var u = 1 - (longNumber / longitudeBands);
        var v = 1 - (latNumber / latitudeBands);

        normalData.push(x);
        normalData.push(y);
        normalData.push(z);
        textureCoordData.push(u);
        textureCoordData.push(v);
        var xValue = radius * x;
        var yValue = radius * y;
        var zValue = radius * z;
        vertexPositionData.push(xValue);
        vertexPositionData.push(yValue);
        vertexPositionData.push(zValue);
        allPoints[longNumber + ":" + (90 - latNumber)] = [ xValue, yValue, zValue ];
      }
    }

    var indexData = [];
    for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
      for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
        var first = (latNumber * (longitudeBands + 1)) + longNumber;
        var second = first + longitudeBands + 1;
        indexData.push(first);
        indexData.push(second);
        indexData.push(first + 1);

        indexData.push(second);
        indexData.push(second + 1);
        indexData.push(first + 1);
      }
    }

    mesh.addAttributeBuffer("aVertexPosition", vertexPositionData, 3);

    mesh.addAttributeBuffer("aTextureCoord", textureCoordData, 2);

    mesh.addAttributeBuffer("aVertexNormal", normalData, 3);

    mesh.addIndexBuffer(indexData);
  }

  var shader, mesh, uniforms = {};

  var lineShader, lineMeshes = [];

  function createLinePath(startKey, endKey, messageKey, isSelect) {

    var pointPath = getPointData(startKey, endKey);

    var lineMesh = lineShader.createMesh();

    lineMesh.addAttributeBuffer("aVertexPosition", pointPath, 3);

    lineMeshes.push({key: messageKey, value: lineMesh, isSelect: isSelect || false});
  }

  function getPointData(startKey, endKey) {

    var start = allPoints[startKey];
    var end = allPoints[endKey];
    var midPoint = Vector.create((start[0] + end[0]) / 2,
        (start[1] + end[1]) / 2, (start[2] + end[2]) / 2);

    // the longer distance, higher line
    var distance = Math.sqrt(Math.pow((start[0] - end[0]), 2)
        + Math.pow((start[1] - end[1]), 2) + Math.pow((start[2] - end[2]), 2));

    var distancePercentage = distance / (radius * 2);
    
    if (distancePercentage <= 0.82) {
      // bezier point = (mid point coordinate / (len / radius))
      // definite proportion point
      var len = midPoint.length();
      //var percent = len / d;
      var percent = radius / len;
      // multi-number = mid point's surface coordinate * ((distance / diameter) + 1)
      // if radius = 2, bezier point 's range is (2, 4]
      var bezierPoint = midPoint.multiply(percent).multiply(distancePercentage * 1 + 1);

      return bezierCurve2(start, bezierPoint.toArray(), end);
    } else {
      
      var midArr = midPoint.toArray();
      
      var len2 = midPoint.length();
      var percent2 = radius / len2;
      var bezierPoint2 = midPoint.multiply(percent2).multiply(distancePercentage * 1 + 1);
      
      midArr = bezierPoint2.toArray();
      
      var firstBezier = Vector.create((start[0] + midArr[0]) / 100, (start[1] + midArr[1]) / 100, (start[2] + midArr[2]) / 100);
      var len1 = firstBezier.length();
      var percent1 = radius / len1;
      firstBezier = firstBezier.multiply(percent1).multiply(distancePercentage * 1.13 + 1);

      var secondBezier = Vector.create((midArr[0] + end[0]) * 99 / 100, (midArr[1] + end[1]) * 99 / 100, (midArr[2] + end[2]) * 99 / 100);
      var len3 = secondBezier.length();
      var percent3 = radius / len3;
      secondBezier = secondBezier.multiply(percent3).multiply(distancePercentage * 1.13 + 1);
      
      return bezierCurve4(start, firstBezier.toArray(), bezierPoint2.multiply(0.5).toArray(), secondBezier.toArray(), end);
    }
    
  }

  function webGLStart() {
    var canvas = document.getElementById("canvas");
    shader = Shader.create(canvas, "shader-vs", "shader-fs");
    if (shader == null) {
      return;
    }

    mesh = shader.createMesh();

    lineShader = Shader.create(canvas, "line-vs", "line-fs");

    uniforms.uPMatrix = Matrix.perspective(45, shader.canvas.width
        / shader.canvas.height, 0.1, 100.0);

    initBuffers();

    shader.clearColor(0.0, 0.0, 0.0, 1.0);
    shader.depthTest();

    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    shader.ondraw = drawScene;

    TextureLoader.mitMap(shader.gl, "image/earth.jpg", function(texture) {
      uniforms.uSampler = texture;
      shader.animate();
    });
  }

  function drawScene() {

    var gl = this.gl;

    this.viewport();
    this.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    uniforms.uUseLighting = document.getElementById("lighting").checked;

    if (uniforms.uUseLighting) {

      uniforms.uAmbientColor = [
          parseFloat(document.getElementById("ambientR").value),
          parseFloat(document.getElementById("ambientG").value),
          parseFloat(document.getElementById("ambientB").value) ];

      var lightingDirection = Vector.create(parseFloat(document
          .getElementById("lightDirectionX").value), parseFloat(document
          .getElementById("lightDirectionY").value), parseFloat(document
          .getElementById("lightDirectionZ").value));

      var adjustedLD = lightingDirection.normalize(false);

      adjustedLD = adjustedLD.multiply(-1);

      uniforms.uLightingDirection = adjustedLD;

      uniforms.uDirectionalColor = [
          parseFloat(document.getElementById("directionalR").value),
          parseFloat(document.getElementById("directionalG").value),
          parseFloat(document.getElementById("directionalB").value) ];

    }

    var mvMatrix = new Matrix();

    mvMatrix.translate(0.0, 0.0, -6.0);

    mvMatrix = Matrix.multiply(mvMatrix, moonRotationMatrix);

    uniforms.uMVMatrix = mvMatrix;

    uniforms.uNMatrix = mvMatrix.inverseTranspose();

    this.uniforms(uniforms).draw(mesh, gl.TRIANGLES);

    // draw line
    for (var index = 0; index < lineMeshes.length; index++) {
      
      uniforms.uSelect = lineMeshes[index].isSelect || false;
      lineShader.uniforms(uniforms).draw(lineMeshes[index].value, gl.LINE_STRIP);
    }
  }

  function translateLongitude(value) {
    if (value >= 180) {
      return (value - 180) + 'W';
    } else {
      return (180 - value) + 'E';
    }
  }
  
  function translateLatitude(value) {
    if (value > 0) {
      return value + "N";
    } else {
      return Math.abs(value) + "S";
    }
  }
  
  function showValue(value, displayId) {

    var displayDiv = document.getElementById(displayId);

    displayDiv.innerHTML = value;
  }

  function initDisplay() {
    showValue(translateLongitude(document.getElementById("startLongitude").value),
        "displayStartLongitude");
    showValue(translateLatitude(document.getElementById("startLatitude").value),
        "displayStartLatitude");
    showValue(translateLongitude(document.getElementById("endLongitude").value),
        "displayEndLongitude");
    showValue(translateLatitude(document.getElementById("endLatitude").value),
        "displayEndLatitude");

    // add init path
    addAirLinePath(58, 31, 42, 36, "Shanghai->Tokyo", true);

    addAirLinePath(58, 31, 30, -34, "Shanghai->Sydney");
    
    addAirLinePath(58, 31, 143, 55, "Shanghai->Moscow");
    
    addAirLinePath(58, 31, 103, 28, "Shanghai->New Delhi");
    
    addAirLinePath(42, 36, 255, 40, "Tokyo->NewYork");
    
    addAirLinePath(143, 55, 180, 53, "Moscow->London");
    
    addAirLinePath(52, 38, 42, 36, "Seoul->Tokyo");
    
    addAirLinePath(149, 30, 103, 28, "Cairo->New Delhi");
    
    addAirLinePath(162, -33, 149, 30, "Cape Down->Cairo");
    
    addAirLinePath(149, 30, 175, 53, "Cairo->Amsterdam");
    
  }

  function addAirLinePath(startLongitudeValue, startLatitudeValue, endLongitudeValue, endLatitudeValue, additionalValue, isSelect) {
    
    var key = "Start[" + translateLongitude(startLongitudeValue) + ":" + translateLatitude(startLatitudeValue) + 
                     "] End[" + translateLongitude(endLongitudeValue) + ":" + translateLatitude(endLatitudeValue) + "]";
    
    if (indexOfLineMeshes(key) != -1) {
      alert("The coordinate is duplicated.");
      return;
    }
    
    createLinePath(startLongitudeValue + ":" + startLatitudeValue,
        endLongitudeValue + ":" + endLatitudeValue, key, isSelect);
    
    addConsole(key, additionalValue, isSelect);
  }
  
  function addAirLinePathFromControl() {
    
    var startLongitude = document.getElementById("startLongitude");
    var startLatitude = document.getElementById("startLatitude");
    var endLongitude = document.getElementById("endLongitude");
    var endLatitude = document.getElementById("endLatitude");
    
    addAirLinePath(startLongitude.value, startLatitude.value, endLongitude.value, endLatitude.value);
  }
  
  function addConsole(message, additionalValue, isSelect) {
    
    var consoleDiv = document.getElementById("console");
    
    var itemDiv = document.createElement("div");
    
    itemDiv.className = "displayItem";
    itemDiv.title = "Click and select air line"
    itemDiv.key = message;
    
    if (isSelect == true) {
      itemDiv.style.backgroundColor = "#BCD";
    }
    
    var messageDiv = document.createElement("div");
    if (additionalValue != null) {
      messageDiv.innerHTML = message + " " + additionalValue;
    } else {
      messageDiv.innerHTML = message;
    }
    
    messageDiv.className = "messageItem";
    
    var btnDiv = document.createElement("div");
    
    btnDiv.innerHTML = "×";
    btnDiv.className = "closeButton";
    btnDiv.title = "Delete air line";

    itemDiv.appendChild(btnDiv);
    itemDiv.appendChild(messageDiv);
    
    consoleDiv.appendChild(itemDiv);
  }
  
  function removeLine(key) {
    var index = indexOfLineMeshes(key);
    if (index == -1) {
      return;
    }
    lineMeshes.splice(index, 1);
  }
  
  function indexOfLineMeshes(key) {
    
    for (var index = 0; index < lineMeshes.length; index++) {
      if (lineMeshes[index].key == key) {
        return index;
      }
    }
    return -1;
  }
  
  function selectRowHandler(key) {
    
    var index = indexOfLineMeshes(key);
    if (index == -1) {
      return;
    }
    
    for (var i = 0; i < lineMeshes.length; i++) {
      lineMeshes[i].isSelect = false;
    }
    
    lineMeshes[index].isSelect = true;
  }
  
</script>
</head>

<body onload="webGLStart();initDisplay();">
<br>

	<div>
		<span>
			<canvas id="canvas" style="border: none;" width="1000" height="1000"></canvas>
		</span>
		<div style="vertical-align:top;display:inline-block;">
		  <div>
				<div style="display:inline-block;">
					<fieldset style="width:260px;">
						<legend>Start Point</legend>
						<table>
							<tr>
								<td>longitude:</td><td><input id="startLongitude" type="range" min="0" max="360" step="1" onchange="showValue(translateLongitude(this.value), 'displayStartLongitude');"></td><td id="displayStartLongitude"></td>
							</tr>
							<tr>
								<td>latitude:</td><td><input id="startLatitude" type="range" min="-90" max="90" step="1" onchange="showValue(translateLatitude(this.value), 'displayStartLatitude');"></td><td id="displayStartLatitude"></td>
							</tr>
						</table>
					</fieldset>
					<fieldset style="width:260px;">
						<legend>End Point</legend>
						<table>
							<tr>
								<td>longitude:</td><td><input id="endLongitude" type="range" min="0" max="360" step="1" onchange="showValue(translateLongitude(this.value), 'displayEndLongitude');"></td><td id="displayEndLongitude"></td>
							</tr>
							<tr>
								<td>latitude:</td><td><input id="endLatitude" type="range" min="-90" max="90" step="1" onchange="showValue(translateLatitude(this.value), 'displayEndLatitude');"></td><td id="displayEndLatitude"></td>
							</tr>
						</table>
					</fieldset>
				</div>
				<div style="display:inline-block;"">
					<input type="button" value="Add path" onclick="addAirLinePathFromControl();"/>
				</div>
			</div>
			<div style="margin-top:4px;">
        Display List (Clicking row will select an air line):
        <div id="console">
        </div>
      </div>
		</div>
		
	</div>
    
	<div>
    <div>
      <input type="checkbox" id="lighting" checked />Enable light
    </div>
    <div style="color:red;">Drag & drop earth to rotate</div>	
	</div>
    
    <div style="display:none;">

    <h2>Direction：</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>light：</b>
            <td>X: <input type="text" id="lightDirectionX" value="-1.0" />
            <td>Y: <input type="text" id="lightDirectionY" value="-1.0" />
            <td>Z: <input type="text" id="lightDirectionZ" value="-1.0" />
        </tr>
        <tr>
            <td><b>color：</b>
            <td>R: <input type="text" id="directionalR" value="0.8" />
            <td>G: <input type="text" id="directionalG" value="0.8" />
            <td>B: <input type="text" id="directionalB" value="0.8" />
        </tr>
    </table>
    <h2>Ambient：</h2>

    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>color</b>
            <td>R: <input type="text" id="ambientR" value="0.2" />
            <td>G: <input type="text" id="ambientG" value="0.2" />
            <td>B: <input type="text" id="ambientB" value="0.2" />
        </tr>
    </table>
    </div>
    
    <script type="text/javascript">
    
    var BehaviorManager = {
        
        handlerMap: {},
        
        register: function(elementId, config) {
        
          if (this.handlerMap[elementId] != null) {
            this.handlerMap[elementId].push(config);
            return;
          }
          
          this.handlerMap[elementId] = [config];
          
          var targetThis = this;
          
          var handler = (function(id) {
            return function(e) {
              
              var event = e || window.event;
              var target = e.target || e.srcElement;
              
              var targetClass = target.className;
              
              var handlers = targetThis.handlerMap[id];
              
              for (var i = 0; i < handlers.length; i++) {
                if (targetClass.indexOf(handlers[i].target) == -1) {
                  continue;
                }
                handlers[i].callback(target);
              }
              
            };
          })(elementId);
          
          document.getElementById(elementId).addEventListener(config.eventType, handler, false);
        }
    }

    var behaviorHandlers = [{
      target: "messageItem",
      eventType: "click",
      callback: function(target) {
        var displayItem = target.parentNode;
        var container = displayItem.parentNode;
        
        var itemList = container.getElementsByTagName("div");
        
        for (var i = 0; i < itemList.length; i++) {
          if (itemList[i].className != "displayItem") {
            continue;
          }
          
          itemList[i].style.backgroundColor = "";
        }
        
        displayItem.style.backgroundColor = "#BCD";
        
        selectRowHandler(displayItem.key);
      }
    }, {
      target: "closeButton",
      eventType: "click",
      callback: function(target) {
        var displayItem = target.parentNode;
        var container = displayItem.parentNode;
        container.removeChild(displayItem);
        removeLine(displayItem.key);
      }
    }];
    
    behaviorHandlers.forEach(function(handler) {
      BehaviorManager.register("console", handler);
    });
    
    </script>
</body>
</html>
